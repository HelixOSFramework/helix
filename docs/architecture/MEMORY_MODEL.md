# Helix Memory Model

<div align="center">

ğŸ§  **Complete Memory Architecture Reference**

*Physical memory, virtual memory, and allocation strategies*

</div>

---

## Table of Contents

1. [Memory Overview](#1-memory-overview)
2. [Physical Memory](#2-physical-memory)
3. [Virtual Memory](#3-virtual-memory)
4. [Allocator Framework](#4-allocator-framework)
5. [Kernel Heap](#5-kernel-heap)
6. [Page Tables](#6-page-tables)
7. [Memory Protection](#7-memory-protection)
8. [NUMA Considerations](#8-numa-considerations)
9. [Memory Statistics](#9-memory-statistics)

---

## 1. Memory Overview

### 1.1 Memory Hierarchy

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                       HELIX MEMORY HIERARCHY                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  Application Layer                                                          â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  User Applications                                                  â”‚   â”‚
â”‚  â”‚  â””â”€â”€ malloc/free (user heap)                                        â”‚   â”‚
â”‚  â”‚  â””â”€â”€ mmap (virtual memory)                                          â”‚   â”‚
â”‚  â”‚  â””â”€â”€ Stack (automatic)                                              â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                      â”‚                                      â”‚
â”‚                                      â–¼                                      â”‚
â”‚  Syscall Layer                                                              â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  sys_brk       - Adjust heap size                                   â”‚   â”‚
â”‚  â”‚  sys_mmap      - Map virtual memory                                 â”‚   â”‚
â”‚  â”‚  sys_munmap    - Unmap virtual memory                               â”‚   â”‚
â”‚  â”‚  sys_mprotect  - Change page protection                             â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                      â”‚                                      â”‚
â”‚                                      â–¼                                      â”‚
â”‚  Kernel Memory Management                                                   â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•                                                   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  Virtual Memory Manager                                             â”‚   â”‚
â”‚  â”‚  â”œâ”€â”€ Page table management                                          â”‚   â”‚
â”‚  â”‚  â”œâ”€â”€ Virtual address allocation                                     â”‚   â”‚
â”‚  â”‚  â””â”€â”€ Memory mapping (file-backed, anonymous)                        â”‚   â”‚
â”‚  â”‚                                                                     â”‚   â”‚
â”‚  â”‚  Physical Memory Manager                                            â”‚   â”‚
â”‚  â”‚  â”œâ”€â”€ Frame allocation                                               â”‚   â”‚
â”‚  â”‚  â”œâ”€â”€ Free list management                                           â”‚   â”‚
â”‚  â”‚  â””â”€â”€ Reference counting                                             â”‚   â”‚
â”‚  â”‚                                                                     â”‚   â”‚
â”‚  â”‚  Kernel Heap                                                        â”‚   â”‚
â”‚  â”‚  â”œâ”€â”€ Bump allocator (boot time)                                     â”‚   â”‚
â”‚  â”‚  â”œâ”€â”€ Slab allocator (kernel objects)                                â”‚   â”‚
â”‚  â”‚  â””â”€â”€ General allocator (misc)                                       â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                      â”‚                                      â”‚
â”‚                                      â–¼                                      â”‚
â”‚  Hardware Layer                                                             â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  MMU (Memory Management Unit)                                       â”‚   â”‚
â”‚  â”‚  â”œâ”€â”€ TLB (Translation Lookaside Buffer)                             â”‚   â”‚
â”‚  â”‚  â”œâ”€â”€ Page table walker                                              â”‚   â”‚
â”‚  â”‚  â””â”€â”€ Access permission checks                                       â”‚   â”‚
â”‚  â”‚                                                                     â”‚   â”‚
â”‚  â”‚  Physical RAM                                                       â”‚   â”‚
â”‚  â”‚  â””â”€â”€ DRAM modules                                                   â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 1.2 Memory Subsystem Components

| Component | Crate | Purpose |
|-----------|-------|---------|
| Frame Allocator | `helix-memory` | Physical page allocation |
| Virtual Memory | `helix-memory` | Page table management |
| Region Manager | `helix-memory` | Virtual region tracking |
| Kernel Heap | `helix-minimal-os` | Dynamic kernel allocation |
| HAL Memory | `helix-hal` | Hardware abstraction |

---

## 2. Physical Memory

### 2.1 Physical Address Space

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    x86_64 PHYSICAL ADDRESS SPACE                            â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  52 bits addressable = 4 PB physical address space                          â”‚
â”‚  (Typical systems: 16GB - 1TB actual RAM)                                   â”‚
â”‚                                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ 0x0000_0000_0000_0000  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    â”‚   â”‚
â”‚  â”‚ â”‚                                                                   â”‚   â”‚
â”‚  â”‚ â”‚  Conventional Memory (0 - 1MB)                                    â”‚   â”‚
â”‚  â”‚ â”‚  â”œâ”€â”€ IVT, BDA, free, boot sector, video, ROM                     â”‚   â”‚
â”‚  â”‚ â”‚                                                                   â”‚   â”‚
â”‚  â”‚ â”‚ 0x0000_0000_0010_0000  (1 MB) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   â”‚   â”‚
â”‚  â”‚ â”‚                                                                   â”‚   â”‚
â”‚  â”‚ â”‚  Extended Memory                                                  â”‚   â”‚
â”‚  â”‚ â”‚  â”œâ”€â”€ Kernel image                                                â”‚   â”‚
â”‚  â”‚ â”‚  â”œâ”€â”€ Kernel heap                                                 â”‚   â”‚
â”‚  â”‚ â”‚  â”œâ”€â”€ User memory                                                 â”‚   â”‚
â”‚  â”‚ â”‚  â””â”€â”€ Most RAM lives here                                         â”‚   â”‚
â”‚  â”‚ â”‚                                                                   â”‚   â”‚
â”‚  â”‚ â”‚ End of RAM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   â”‚   â”‚
â”‚  â”‚ â”‚                                                                   â”‚   â”‚
â”‚  â”‚ â”‚  Memory Hole (ISA, PCI, etc.)                                    â”‚   â”‚
â”‚  â”‚ â”‚                                                                   â”‚   â”‚
â”‚  â”‚ â”‚ 0x0000_0000_FEC0_0000  (APIC) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€   â”‚   â”‚
â”‚  â”‚ â”‚                                                                   â”‚   â”‚
â”‚  â”‚ â”‚  Memory-Mapped I/O                                               â”‚   â”‚
â”‚  â”‚ â”‚  â”œâ”€â”€ APIC registers                                              â”‚   â”‚
â”‚  â”‚ â”‚  â”œâ”€â”€ PCIe config space                                           â”‚   â”‚
â”‚  â”‚ â”‚  â””â”€â”€ Device memory                                               â”‚   â”‚
â”‚  â”‚ â”‚                                                                   â”‚   â”‚
â”‚  â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚   â”‚
â”‚  â”‚                                                                     â”‚   â”‚
â”‚  â”‚  Above 4GB (if present):                                            â”‚   â”‚
â”‚  â”‚  â”œâ”€â”€ Extended physical memory                                       â”‚   â”‚
â”‚  â”‚  â””â”€â”€ Mapped by PAE/Long Mode paging                                 â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 2.2 Physical Frame

```rust
/// Represents a physical memory frame (page)
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Frame {
    /// Physical address of the frame (page-aligned)
    address: PhysAddr,
    /// Size of the frame (4KB, 2MB, or 1GB)
    size: PageSize,
}

impl Frame {
    /// Create a new frame at the given physical address
    pub const fn new(address: PhysAddr, size: PageSize) -> Self {
        Self { address, size }
    }
    
    /// Get the physical address
    pub fn address(&self) -> PhysAddr {
        self.address
    }
    
    /// Get the size of this frame
    pub fn size(&self) -> PageSize {
        self.size
    }
    
    /// Get the frame containing a physical address
    pub fn containing(addr: PhysAddr) -> Self {
        Self {
            address: PhysAddr::new(addr.as_u64() & !0xFFF),
            size: PageSize::Size4K,
        }
    }
    
    /// Get the frame number
    pub fn number(&self) -> u64 {
        self.address.as_u64() / self.size.bytes() as u64
    }
}

/// Page sizes supported by x86_64
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum PageSize {
    /// 4 KB standard page
    Size4K = 4096,
    /// 2 MB huge page
    Size2M = 2 * 1024 * 1024,
    /// 1 GB giant page
    Size1G = 1024 * 1024 * 1024,
}

impl PageSize {
    pub const fn bytes(&self) -> usize {
        match self {
            PageSize::Size4K => 4096,
            PageSize::Size2M => 2 * 1024 * 1024,
            PageSize::Size1G => 1024 * 1024 * 1024,
        }
    }
}
```

### 2.3 Physical Allocator Trait

```rust
/// Trait for physical frame allocators
pub trait PhysicalAllocator: Send + Sync {
    /// Allocate a single frame
    fn allocate(&self) -> MemResult<Frame>;
    
    /// Allocate multiple contiguous frames
    fn allocate_contiguous(&self, count: usize) -> MemResult<Frame>;
    
    /// Deallocate a frame
    fn deallocate(&self, frame: Frame) -> MemResult<()>;
    
    /// Deallocate contiguous frames
    fn deallocate_contiguous(&self, frame: Frame, count: usize) -> MemResult<()>;
    
    /// Get the number of available frames
    fn available_frames(&self) -> usize;
    
    /// Get total frames (allocated + available)
    fn total_frames(&self) -> usize;
    
    /// Get memory statistics
    fn stats(&self) -> MemoryStats;
}
```

---

## 3. Virtual Memory

### 3.1 Virtual Address Space Layout

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    VIRTUAL ADDRESS SPACE (64-bit)                           â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  Only 48 bits of virtual address are used (canonical addresses)             â”‚
â”‚  Upper 16 bits must be sign extension of bit 47                             â”‚
â”‚                                                                             â”‚
â”‚  KERNEL SPACE (negative/high addresses)                                     â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•                                    â”‚
â”‚                                                                             â”‚
â”‚  0xFFFF_FFFF_FFFF_FFFF  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚                         â”‚  Kernel Stack (per-CPU)                      â”‚   â”‚
â”‚  0xFFFF_FFFF_FF00_0000  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
â”‚                         â”‚  Kernel Module Space                         â”‚   â”‚
â”‚  0xFFFF_FFFF_C000_0000  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
â”‚                         â”‚  vmalloc Area                                â”‚   â”‚
â”‚  0xFFFF_FFC0_0000_0000  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
â”‚                         â”‚                                              â”‚   â”‚
â”‚                         â”‚  Direct Physical Mapping                     â”‚   â”‚
â”‚                         â”‚  (all physical RAM mapped here)              â”‚   â”‚
â”‚                         â”‚                                              â”‚   â”‚
â”‚  0xFFFF_8800_0000_0000  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
â”‚                         â”‚  Kernel Text/Data                            â”‚   â”‚
â”‚  0xFFFF_8000_0000_0000  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                             â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•   â”‚
â”‚                         NON-CANONICAL HOLE                                  â”‚
â”‚                         (addresses 0x8000... to 0xFFFF7FFF... invalid)      â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•   â”‚
â”‚                                                                             â”‚
â”‚  USER SPACE (positive/low addresses)                                        â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•                                        â”‚
â”‚                                                                             â”‚
â”‚  0x0000_7FFF_FFFF_FFFF  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚                         â”‚  User Stack (grows down)                     â”‚   â”‚
â”‚  0x0000_7FFF_0000_0000  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
â”‚                         â”‚  Memory Mapped Files                         â”‚   â”‚
â”‚  0x0000_7F00_0000_0000  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
â”‚                         â”‚  Shared Libraries                            â”‚   â”‚
â”‚  0x0000_0000_4000_0000  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
â”‚                         â”‚  User Heap (grows up)                        â”‚   â”‚
â”‚  0x0000_0000_1000_0000  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
â”‚                         â”‚  User BSS                                    â”‚   â”‚
â”‚                         â”‚  User Data                                   â”‚   â”‚
â”‚                         â”‚  User Text                                   â”‚   â”‚
â”‚  0x0000_0000_0040_0000  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
â”‚                         â”‚  Reserved (NULL guard, etc.)                 â”‚   â”‚
â”‚  0x0000_0000_0000_0000  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.2 Virtual Address Translation

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    VIRTUAL ADDRESS TRANSLATION                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  64-bit Virtual Address:                                                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚
â”‚  â”‚  Sign  â”‚  PML4   â”‚  PDPT   â”‚   PD    â”‚   PT    â”‚   Offset   â”‚            â”‚
â”‚  â”‚  Ext   â”‚  Index  â”‚  Index  â”‚  Index  â”‚  Index  â”‚            â”‚            â”‚
â”‚  â”‚ 63-48  â”‚  47-39  â”‚  38-30  â”‚  29-21  â”‚  20-12  â”‚   11-0     â”‚            â”‚
â”‚  â”‚ 16 bitsâ”‚  9 bits â”‚  9 bits â”‚  9 bits â”‚  9 bits â”‚  12 bits   â”‚            â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”´â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”´â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”´â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜            â”‚
â”‚                â”‚         â”‚         â”‚         â”‚          â”‚                   â”‚
â”‚                â”‚         â”‚         â”‚         â”‚          â”‚                   â”‚
â”‚                â–¼         â”‚         â”‚         â”‚          â”‚                   â”‚
â”‚           â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚         â”‚         â”‚          â”‚                   â”‚
â”‚    CR3â”€â”€â”€â–¶â”‚  PML4   â”‚    â”‚         â”‚         â”‚          â”‚                   â”‚
â”‚           â”‚  Table  â”‚    â”‚         â”‚         â”‚          â”‚                   â”‚
â”‚           â”‚ 512 ent â”‚    â”‚         â”‚         â”‚          â”‚                   â”‚
â”‚           â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜    â”‚         â”‚         â”‚          â”‚                   â”‚
â”‚                â”‚         â–¼         â”‚         â”‚          â”‚                   â”‚
â”‚                â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚         â”‚          â”‚                   â”‚
â”‚                â””â”€â”€â”€â–¶â”‚  PDPT   â”‚    â”‚         â”‚          â”‚                   â”‚
â”‚                     â”‚  Table  â”‚    â”‚         â”‚          â”‚                   â”‚
â”‚                     â”‚ 512 ent â”‚    â”‚         â”‚          â”‚                   â”‚
â”‚                     â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜    â”‚         â”‚          â”‚                   â”‚
â”‚                          â”‚         â–¼         â”‚          â”‚                   â”‚
â”‚                          â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚          â”‚                   â”‚
â”‚                          â””â”€â”€â”€â–¶â”‚   PD    â”‚    â”‚          â”‚                   â”‚
â”‚                               â”‚  Table  â”‚    â”‚          â”‚                   â”‚
â”‚                               â”‚ 512 ent â”‚    â”‚          â”‚                   â”‚
â”‚                               â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜    â”‚          â”‚                   â”‚
â”‚                                    â”‚         â–¼          â”‚                   â”‚
â”‚                                    â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚                   â”‚
â”‚                                    â””â”€â”€â”€â–¶â”‚   PT    â”‚     â”‚                   â”‚
â”‚                                         â”‚  Table  â”‚     â”‚                   â”‚
â”‚                                         â”‚ 512 ent â”‚     â”‚                   â”‚
â”‚                                         â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜     â”‚                   â”‚
â”‚                                              â”‚          â”‚                   â”‚
â”‚                                              â–¼          â”‚                   â”‚
â”‚                                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”‚                   â”‚
â”‚                                    â”‚ Physical Pageâ”‚â—€â”€â”€â”€â”€â”˜                   â”‚
â”‚                                    â”‚   (4 KB)     â”‚   + Offset              â”‚
â”‚                                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                         â”‚
â”‚                                              â”‚                              â”‚
â”‚                                              â–¼                              â”‚
â”‚                                    Physical Address                         â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 3.3 Virtual Memory Manager

```rust
/// Virtual memory manager for a process
pub struct VirtualMemoryManager {
    /// Root page table (PML4)
    pml4: PhysAddr,
    
    /// Virtual memory regions
    regions: Vec<VmRegion>,
    
    /// Next available virtual address
    next_addr: VirtAddr,
}

/// A contiguous region of virtual memory
pub struct VmRegion {
    /// Start address
    start: VirtAddr,
    
    /// End address (exclusive)
    end: VirtAddr,
    
    /// Protection flags
    protection: Protection,
    
    /// Mapping type
    mapping: MappingType,
    
    /// Name (for debugging)
    name: &'static str,
}

/// Memory protection flags
bitflags! {
    pub struct Protection: u64 {
        const READ    = 1 << 0;
        const WRITE   = 1 << 1;
        const EXECUTE = 1 << 2;
        const USER    = 1 << 3;
    }
}

/// Type of memory mapping
pub enum MappingType {
    /// Anonymous memory (zero-filled on demand)
    Anonymous,
    
    /// File-backed mapping
    File {
        inode: u64,
        offset: u64,
    },
    
    /// Physical memory mapping (for drivers)
    Physical {
        phys_addr: PhysAddr,
    },
    
    /// Shared memory
    Shared {
        id: u64,
    },
}
```

---

## 4. Allocator Framework

### 4.1 Allocator Types

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                       ALLOCATOR COMPARISON                                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                     BUMP ALLOCATOR                                  â”‚   â”‚
â”‚  â”‚                                                                     â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚   â”‚
â”‚  â”‚  â”‚ A1  â”‚ A2  â”‚ A3  â”‚ A4  â”‚           Free Space              â”‚    â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚   â”‚
â”‚  â”‚                          â–²                                          â”‚   â”‚
â”‚  â”‚                          â”‚                                          â”‚   â”‚
â”‚  â”‚                      next_ptr                                       â”‚   â”‚
â”‚  â”‚                                                                     â”‚   â”‚
â”‚  â”‚  Pros: O(1) allocate, simple, no fragmentation (during phase)     â”‚   â”‚
â”‚  â”‚  Cons: No individual deallocation, memory not reused              â”‚   â”‚
â”‚  â”‚  Use:  Boot time, temporary allocations, arena allocator          â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                    BITMAP ALLOCATOR                                 â”‚   â”‚
â”‚  â”‚                                                                     â”‚   â”‚
â”‚  â”‚  Bitmap: [1][1][0][1][0][0][0][1][0][0][0][0][0][0][0][0]          â”‚   â”‚
â”‚  â”‚  Memory: [A1 ][A2 ][  ][A3 ][              Free                 ]  â”‚   â”‚
â”‚  â”‚                                                                     â”‚   â”‚
â”‚  â”‚  Pros: Simple, supports deallocation                               â”‚   â”‚
â”‚  â”‚  Cons: O(n) search for contiguous blocks                          â”‚   â”‚
â”‚  â”‚  Use:  Physical frame allocator, simple memory pools              â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                     BUDDY ALLOCATOR                                 â”‚   â”‚
â”‚  â”‚                                                                     â”‚   â”‚
â”‚  â”‚  Level 0 (16 units): [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ]            â”‚   â”‚
â”‚  â”‚  Level 1 (8 units):  [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ][â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘]          â”‚   â”‚
â”‚  â”‚  Level 2 (4 units):  [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ][â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘][â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘][â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘]      â”‚   â”‚
â”‚  â”‚  Level 3 (2 units):  [â–ˆâ–ˆâ–ˆâ–ˆ][â–‘â–‘â–‘â–‘][â–‘â–‘â–‘â–‘][â–‘â–‘â–‘â–‘][â–‘â–‘â–‘â–‘][â–‘â–‘â–‘â–‘]...       â”‚   â”‚
â”‚  â”‚  Level 4 (1 unit):   [â–ˆâ–ˆ][â–‘â–‘][â–‘â–‘][â–‘â–‘][â–‘â–‘][â–‘â–‘][â–‘â–‘][â–‘â–‘]...           â”‚   â”‚
â”‚  â”‚                                                                     â”‚   â”‚
â”‚  â”‚  Pros: O(log n) allocate/deallocate, good for power-of-2 sizes    â”‚   â”‚
â”‚  â”‚  Cons: Internal fragmentation, complex implementation             â”‚   â”‚
â”‚  â”‚  Use:  Physical memory allocator, large allocations               â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                      SLAB ALLOCATOR                                 â”‚   â”‚
â”‚  â”‚                                                                     â”‚   â”‚
â”‚  â”‚  Cache: "thread_struct" (size: 128 bytes)                          â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚   â”‚
â”‚  â”‚  â”‚ Slab 1 (full):     [T1][T2][T3][T4][T5][T6][T7][T8]         â”‚  â”‚   â”‚
â”‚  â”‚  â”‚ Slab 2 (partial):  [T9][â”€â”€][T10][â”€â”€][â”€â”€][T11][â”€â”€][â”€â”€]       â”‚  â”‚   â”‚
â”‚  â”‚  â”‚ Slab 3 (empty):    [â”€â”€][â”€â”€][â”€â”€][â”€â”€][â”€â”€][â”€â”€][â”€â”€][â”€â”€]         â”‚  â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚   â”‚
â”‚  â”‚                                                                     â”‚   â”‚
â”‚  â”‚  Pros: O(1) allocate/deallocate, no fragmentation, cache-friendly â”‚   â”‚
â”‚  â”‚  Cons: One cache per object type, memory overhead for caches      â”‚   â”‚
â”‚  â”‚  Use:  Kernel objects (threads, files, inodes)                    â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 4.2 Bump Allocator Implementation

```rust
/// Simple bump allocator for kernel heap
pub struct BumpAllocator {
    /// Start of heap region
    heap_start: usize,
    
    /// End of heap region
    heap_end: usize,
    
    /// Next allocation address
    next: AtomicUsize,
    
    /// Number of allocations
    allocations: AtomicUsize,
}

impl BumpAllocator {
    /// Create a new bump allocator
    pub const fn new() -> Self {
        Self {
            heap_start: 0,
            heap_end: 0,
            next: AtomicUsize::new(0),
            allocations: AtomicUsize::new(0),
        }
    }
    
    /// Initialize the allocator with a memory region
    pub unsafe fn init(&mut self, heap_start: usize, heap_size: usize) {
        self.heap_start = heap_start;
        self.heap_end = heap_start + heap_size;
        self.next.store(heap_start, Ordering::SeqCst);
    }
    
    /// Allocate memory
    pub fn allocate(&self, layout: Layout) -> Option<*mut u8> {
        loop {
            let current = self.next.load(Ordering::SeqCst);
            
            // Align the address
            let aligned = align_up(current, layout.align());
            let new_next = aligned + layout.size();
            
            // Check bounds
            if new_next > self.heap_end {
                return None; // Out of memory
            }
            
            // Try to update next pointer
            match self.next.compare_exchange_weak(
                current,
                new_next,
                Ordering::SeqCst,
                Ordering::SeqCst,
            ) {
                Ok(_) => {
                    self.allocations.fetch_add(1, Ordering::SeqCst);
                    return Some(aligned as *mut u8);
                }
                Err(_) => continue, // Retry
            }
        }
    }
    
    /// Get usage statistics
    pub fn stats(&self) -> AllocatorStats {
        let next = self.next.load(Ordering::SeqCst);
        AllocatorStats {
            total_bytes: self.heap_end - self.heap_start,
            used_bytes: next - self.heap_start,
            free_bytes: self.heap_end - next,
            allocations: self.allocations.load(Ordering::SeqCst),
        }
    }
}

fn align_up(addr: usize, align: usize) -> usize {
    (addr + align - 1) & !(align - 1)
}
```

### 4.3 Bitmap Allocator Implementation

```rust
/// Bitmap-based physical frame allocator
pub struct BitmapAllocator {
    /// Bitmap (1 bit per frame)
    bitmap: &'static mut [u64],
    
    /// Total number of frames
    total_frames: usize,
    
    /// Number of free frames
    free_frames: AtomicUsize,
    
    /// First frame address
    first_frame: PhysAddr,
    
    /// Lock for bitmap access
    lock: Spinlock<()>,
}

impl BitmapAllocator {
    /// Initialize with a memory region
    pub unsafe fn init(
        bitmap_addr: *mut u64,
        total_frames: usize,
        first_frame: PhysAddr,
    ) -> Self {
        let bitmap_words = (total_frames + 63) / 64;
        let bitmap = core::slice::from_raw_parts_mut(bitmap_addr, bitmap_words);
        
        // Mark all frames as free (0 = free, 1 = allocated)
        bitmap.fill(0);
        
        Self {
            bitmap,
            total_frames,
            free_frames: AtomicUsize::new(total_frames),
            first_frame,
            lock: Spinlock::new(()),
        }
    }
    
    /// Allocate a single frame
    pub fn allocate(&self) -> MemResult<Frame> {
        let _guard = self.lock.lock();
        
        // Find first free bit
        for (word_idx, word) in self.bitmap.iter_mut().enumerate() {
            if *word != u64::MAX {
                // Found a word with at least one free bit
                let bit_idx = (*word).trailing_ones() as usize;
                let frame_idx = word_idx * 64 + bit_idx;
                
                if frame_idx >= self.total_frames {
                    return Err(MemError::OutOfMemory);
                }
                
                // Mark as allocated
                *word |= 1 << bit_idx;
                self.free_frames.fetch_sub(1, Ordering::SeqCst);
                
                let addr = self.first_frame.as_u64() + (frame_idx as u64 * 4096);
                return Ok(Frame::new(PhysAddr::new(addr), PageSize::Size4K));
            }
        }
        
        Err(MemError::OutOfMemory)
    }
    
    /// Deallocate a frame
    pub fn deallocate(&self, frame: Frame) -> MemResult<()> {
        let _guard = self.lock.lock();
        
        let frame_idx = (frame.address().as_u64() - self.first_frame.as_u64()) / 4096;
        let word_idx = frame_idx as usize / 64;
        let bit_idx = frame_idx as usize % 64;
        
        // Check if in range
        if frame_idx as usize >= self.total_frames {
            return Err(MemError::InvalidAddress);
        }
        
        // Check if allocated
        if self.bitmap[word_idx] & (1 << bit_idx) == 0 {
            return Err(MemError::NotMapped);
        }
        
        // Mark as free
        self.bitmap[word_idx] &= !(1 << bit_idx);
        self.free_frames.fetch_add(1, Ordering::SeqCst);
        
        Ok(())
    }
}
```

---

## 5. Kernel Heap

### 5.1 Kernel Heap Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                        KERNEL HEAP ARCHITECTURE                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  Rust's GlobalAlloc Integration                                             â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•                                            â”‚
â”‚                                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  Box<T>, Vec<T>, String, etc.                                       â”‚   â”‚
â”‚  â”‚          â”‚                                                          â”‚   â”‚
â”‚  â”‚          â–¼                                                          â”‚   â”‚
â”‚  â”‚  alloc::alloc(layout) / alloc::dealloc(ptr, layout)                â”‚   â”‚
â”‚  â”‚          â”‚                                                          â”‚   â”‚
â”‚  â”‚          â–¼                                                          â”‚   â”‚
â”‚  â”‚  #[global_allocator]                                                â”‚   â”‚
â”‚  â”‚  static ALLOCATOR: LockedHeap = ...                                 â”‚   â”‚
â”‚  â”‚          â”‚                                                          â”‚   â”‚
â”‚  â”‚          â–¼                                                          â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â”‚
â”‚  â”‚  â”‚  BumpAllocator (during boot)                                â”‚   â”‚   â”‚
â”‚  â”‚  â”‚       or                                                     â”‚   â”‚   â”‚
â”‚  â”‚  â”‚  LinkedListAllocator (after init)                           â”‚   â”‚   â”‚
â”‚  â”‚  â”‚       or                                                     â”‚   â”‚   â”‚
â”‚  â”‚  â”‚  SlabAllocator (for specific types)                         â”‚   â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                             â”‚
â”‚  Heap Memory Layout                                                         â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•                                                         â”‚
â”‚                                                                             â”‚
â”‚  0x300000  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚            â”‚                                                          â”‚    â”‚
â”‚            â”‚                    Kernel Heap                           â”‚    â”‚
â”‚            â”‚                     (1 MB)                               â”‚    â”‚
â”‚            â”‚                                                          â”‚    â”‚
â”‚            â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”                       â”‚    â”‚
â”‚            â”‚  â”‚ Alloc1 â”‚ â”‚ Alloc2 â”‚ â”‚ Alloc3 â”‚ ... â”€â”€â”€â”€â”€â”€â–¶ next     â”‚    â”‚
â”‚            â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜                       â”‚    â”‚
â”‚            â”‚                                                          â”‚    â”‚
â”‚  0x400000  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 5.2 Global Allocator Integration

```rust
use core::alloc::{GlobalAlloc, Layout};

/// Locked heap allocator wrapper
pub struct LockedHeap {
    inner: Spinlock<BumpAllocator>,
}

impl LockedHeap {
    pub const fn empty() -> Self {
        Self {
            inner: Spinlock::new(BumpAllocator::new()),
        }
    }
    
    pub unsafe fn init(&self, heap_start: usize, heap_size: usize) {
        self.inner.lock().init(heap_start, heap_size);
    }
}

unsafe impl GlobalAlloc for LockedHeap {
    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {
        self.inner
            .lock()
            .allocate(layout)
            .unwrap_or(core::ptr::null_mut())
    }
    
    unsafe fn dealloc(&self, _ptr: *mut u8, _layout: Layout) {
        // Bump allocator doesn't support deallocation
        // In a real implementation, this would free memory
    }
}

#[global_allocator]
static ALLOCATOR: LockedHeap = LockedHeap::empty();

/// Initialize kernel heap
pub fn init_heap(heap_start: usize, heap_size: usize) {
    unsafe {
        ALLOCATOR.init(heap_start, heap_size);
    }
    serial_println!("[HEAP] Initialized {} KB at {:#x}", heap_size / 1024, heap_start);
}
```

---

## 6. Page Tables

### 6.1 Page Table Entry Format

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    PAGE TABLE ENTRY (64-bit)                                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  Bit  â”‚ Name        â”‚ Description                                          â”‚
â”‚  â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚
â”‚  0    â”‚ Present (P) â”‚ Page is in memory (1) or not (0)                     â”‚
â”‚  1    â”‚ R/W         â”‚ Writable (1) or read-only (0)                        â”‚
â”‚  2    â”‚ U/S         â”‚ User accessible (1) or kernel only (0)               â”‚
â”‚  3    â”‚ PWT         â”‚ Page Write-Through                                    â”‚
â”‚  4    â”‚ PCD         â”‚ Page Cache Disable                                    â”‚
â”‚  5    â”‚ Accessed    â”‚ Set by CPU when page is accessed                     â”‚
â”‚  6    â”‚ Dirty       â”‚ Set by CPU when page is written                      â”‚
â”‚  7    â”‚ PS/PAT      â”‚ Page Size (1 = huge) / PAT for 4KB pages             â”‚
â”‚  8    â”‚ Global      â”‚ Don't flush from TLB on CR3 change                   â”‚
â”‚  9-11 â”‚ Available   â”‚ For OS use                                           â”‚
â”‚  12-51â”‚ Address     â”‚ Physical address of next level / page (4KB aligned)  â”‚
â”‚  52-62â”‚ Available   â”‚ For OS use                                           â”‚
â”‚  63   â”‚ NX          â”‚ No Execute (requires EFER.NXE = 1)                   â”‚
â”‚                                                                             â”‚
â”‚  Entry format:                                                              â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚
â”‚  â”‚ NX â”‚ Available â”‚    Physical Address (40 bits)    â”‚Availâ”‚Gâ”‚PSâ”‚Aâ”‚PCDâ”‚PWTâ”‚U/Sâ”‚R/Wâ”‚ P â”‚â”‚
â”‚  â”‚ 63 â”‚   62-52   â”‚         51-12                    â”‚11-9 â”‚8â”‚ 7â”‚5â”‚ 4 â”‚ 3 â”‚ 2 â”‚ 1 â”‚ 0 â”‚â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 6.2 Page Table Management

```rust
/// Page table entry
#[repr(transparent)]
pub struct PageTableEntry(u64);

impl PageTableEntry {
    /// Create an empty (not present) entry
    pub const fn empty() -> Self {
        Self(0)
    }
    
    /// Create an entry pointing to a frame
    pub fn new(frame: Frame, flags: PageTableFlags) -> Self {
        Self(frame.address().as_u64() | flags.bits())
    }
    
    /// Check if entry is present
    pub fn is_present(&self) -> bool {
        self.0 & 1 != 0
    }
    
    /// Get the physical address
    pub fn address(&self) -> PhysAddr {
        PhysAddr::new(self.0 & 0x000F_FFFF_FFFF_F000)
    }
    
    /// Get the flags
    pub fn flags(&self) -> PageTableFlags {
        PageTableFlags::from_bits_truncate(self.0)
    }
    
    /// Set the entry
    pub fn set(&mut self, frame: Frame, flags: PageTableFlags) {
        self.0 = frame.address().as_u64() | flags.bits();
    }
    
    /// Clear the entry
    pub fn clear(&mut self) {
        self.0 = 0;
    }
}

bitflags! {
    /// Page table entry flags
    pub struct PageTableFlags: u64 {
        const PRESENT       = 1 << 0;
        const WRITABLE      = 1 << 1;
        const USER          = 1 << 2;
        const WRITE_THROUGH = 1 << 3;
        const NO_CACHE      = 1 << 4;
        const ACCESSED      = 1 << 5;
        const DIRTY         = 1 << 6;
        const HUGE_PAGE     = 1 << 7;
        const GLOBAL        = 1 << 8;
        const NO_EXECUTE    = 1 << 63;
    }
}

/// A page table (512 entries)
#[repr(C, align(4096))]
pub struct PageTable {
    entries: [PageTableEntry; 512],
}

impl PageTable {
    /// Create an empty page table
    pub const fn new() -> Self {
        const EMPTY: PageTableEntry = PageTableEntry::empty();
        Self {
            entries: [EMPTY; 512],
        }
    }
    
    /// Get an entry
    pub fn entry(&self, index: usize) -> &PageTableEntry {
        &self.entries[index]
    }
    
    /// Get a mutable entry
    pub fn entry_mut(&mut self, index: usize) -> &mut PageTableEntry {
        &mut self.entries[index]
    }
}
```

### 6.3 Page Table Walker

```rust
/// Map a virtual address to a physical frame
pub fn map_page(
    pml4: &mut PageTable,
    virt: VirtAddr,
    frame: Frame,
    flags: PageTableFlags,
    allocator: &dyn PhysicalAllocator,
) -> MemResult<()> {
    let indices = [
        virt.pml4_index(),
        virt.pdpt_index(),
        virt.pd_index(),
        virt.pt_index(),
    ];
    
    let mut table = pml4;
    
    // Walk levels 0-2 (PML4, PDPT, PD)
    for &index in &indices[..3] {
        let entry = table.entry_mut(index);
        
        if !entry.is_present() {
            // Allocate new table
            let new_table_frame = allocator.allocate()?;
            
            // Zero the new table
            unsafe {
                let ptr = new_table_frame.address().as_u64() as *mut u8;
                core::ptr::write_bytes(ptr, 0, 4096);
            }
            
            entry.set(new_table_frame, PageTableFlags::PRESENT | PageTableFlags::WRITABLE);
        }
        
        // Get next level table
        let next_addr = entry.address().as_u64() as *mut PageTable;
        table = unsafe { &mut *next_addr };
    }
    
    // Set the final entry (PT entry)
    let pt_entry = table.entry_mut(indices[3]);
    if pt_entry.is_present() {
        return Err(MemError::AlreadyMapped);
    }
    
    pt_entry.set(frame, flags | PageTableFlags::PRESENT);
    
    // Flush TLB for this address
    unsafe {
        core::arch::asm!("invlpg [{}]", in(reg) virt.as_u64());
    }
    
    Ok(())
}

/// Translate a virtual address to physical
pub fn translate(pml4: &PageTable, virt: VirtAddr) -> Option<PhysAddr> {
    let indices = [
        virt.pml4_index(),
        virt.pdpt_index(),
        virt.pd_index(),
        virt.pt_index(),
    ];
    
    let mut table = pml4;
    
    for (level, &index) in indices.iter().enumerate() {
        let entry = table.entry(index);
        
        if !entry.is_present() {
            return None;
        }
        
        // Check for huge pages
        if level < 3 && entry.flags().contains(PageTableFlags::HUGE_PAGE) {
            let offset_mask = match level {
                1 => 0x3FFF_FFFF, // 1GB page
                2 => 0x001F_FFFF, // 2MB page
                _ => unreachable!(),
            };
            let phys = entry.address().as_u64() | (virt.as_u64() & offset_mask);
            return Some(PhysAddr::new(phys));
        }
        
        if level < 3 {
            let next_addr = entry.address().as_u64() as *const PageTable;
            table = unsafe { &*next_addr };
        }
    }
    
    // Add page offset
    let page_offset = virt.as_u64() & 0xFFF;
    Some(PhysAddr::new(table.entry(indices[3]).address().as_u64() + page_offset))
}
```

---

## 7. Memory Protection

### 7.1 Protection Levels

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                       MEMORY PROTECTION LEVELS                              â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  x86_64 Protection Rings                                                    â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•                                                    â”‚
â”‚                                                                             â”‚
â”‚       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                      â”‚
â”‚       â”‚                   Ring 3                    â”‚  User Mode            â”‚
â”‚       â”‚              (Applications)                 â”‚  Least privileged     â”‚
â”‚       â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚                      â”‚
â”‚       â”‚  â”‚              Ring 2                 â”‚   â”‚                      â”‚
â”‚       â”‚  â”‚            (Unused)                 â”‚   â”‚                      â”‚
â”‚       â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â”‚                      â”‚
â”‚       â”‚  â”‚  â”‚          Ring 1             â”‚   â”‚   â”‚                      â”‚
â”‚       â”‚  â”‚  â”‚        (Unused)             â”‚   â”‚   â”‚                      â”‚
â”‚       â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â”‚   â”‚                      â”‚
â”‚       â”‚  â”‚  â”‚  â”‚      Ring 0        â”‚   â”‚   â”‚   â”‚  Kernel Mode          â”‚
â”‚       â”‚  â”‚  â”‚  â”‚     (Kernel)       â”‚   â”‚   â”‚   â”‚  Most privileged      â”‚
â”‚       â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚   â”‚   â”‚                      â”‚
â”‚       â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚   â”‚                      â”‚
â”‚       â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚                      â”‚
â”‚       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                      â”‚
â”‚                                                                             â”‚
â”‚  In practice, Helix uses only Ring 0 (kernel) and Ring 3 (user)            â”‚
â”‚                                                                             â”‚
â”‚  Page-Level Protection                                                      â”‚
â”‚  â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•                                                      â”‚
â”‚                                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚  â”‚  Flag Combinations and Their Effects:                               â”‚  â”‚
â”‚  â”‚                                                                      â”‚  â”‚
â”‚  â”‚  U/S â”‚ R/W â”‚ NX  â”‚ Kernel Read â”‚ Kernel Write â”‚ User Read â”‚ User Write â”‚ User Exec â”‚  â”‚
â”‚  â”‚  â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”‚  â”‚
â”‚  â”‚   0  â”‚  0  â”‚  0  â”‚     âœ“       â”‚      âœ—       â”‚     âœ—     â”‚     âœ—      â”‚     âœ—     â”‚  â”‚
â”‚  â”‚   0  â”‚  1  â”‚  0  â”‚     âœ“       â”‚      âœ“       â”‚     âœ—     â”‚     âœ—      â”‚     âœ—     â”‚  â”‚
â”‚  â”‚   0  â”‚  1  â”‚  1  â”‚     âœ“       â”‚      âœ“       â”‚     âœ—     â”‚     âœ—      â”‚     âœ—     â”‚  â”‚
â”‚  â”‚   1  â”‚  0  â”‚  0  â”‚     âœ“       â”‚      âœ—       â”‚     âœ“     â”‚     âœ—      â”‚     âœ“     â”‚  â”‚
â”‚  â”‚   1  â”‚  0  â”‚  1  â”‚     âœ“       â”‚      âœ—       â”‚     âœ“     â”‚     âœ—      â”‚     âœ—     â”‚  â”‚
â”‚  â”‚   1  â”‚  1  â”‚  0  â”‚     âœ“       â”‚      âœ“       â”‚     âœ“     â”‚     âœ“      â”‚     âœ“     â”‚  â”‚
â”‚  â”‚   1  â”‚  1  â”‚  1  â”‚     âœ“       â”‚      âœ“       â”‚     âœ“     â”‚     âœ“      â”‚     âœ—     â”‚  â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 7.2 SMAP and SMEP

```rust
/// Supervisor Mode Access Prevention (SMAP)
/// Prevents kernel from accessing user memory unless explicitly allowed
pub fn enable_smap() {
    unsafe {
        // Set CR4.SMAP (bit 21)
        let mut cr4: u64;
        core::arch::asm!("mov {}, cr4", out(reg) cr4);
        cr4 |= 1 << 21;
        core::arch::asm!("mov cr4, {}", in(reg) cr4);
    }
}

/// Supervisor Mode Execution Prevention (SMEP)
/// Prevents kernel from executing user-mode pages
pub fn enable_smep() {
    unsafe {
        // Set CR4.SMEP (bit 20)
        let mut cr4: u64;
        core::arch::asm!("mov {}, cr4", out(reg) cr4);
        cr4 |= 1 << 20;
        core::arch::asm!("mov cr4, {}", in(reg) cr4);
    }
}

/// Temporarily allow kernel access to user memory (with SMAP)
pub unsafe fn with_user_access<F, R>(f: F) -> R
where
    F: FnOnce() -> R,
{
    // Clear AC flag to allow user memory access
    core::arch::asm!("stac");
    
    let result = f();
    
    // Set AC flag to restore protection
    core::arch::asm!("clac");
    
    result
}
```

---

## 8. NUMA Considerations

### 8.1 NUMA Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         NUMA ARCHITECTURE                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                             â”‚
â”‚  Non-Uniform Memory Access (NUMA) - memory access time varies by location  â”‚
â”‚                                                                             â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚                                                                       â”‚ â”‚
â”‚  â”‚     NODE 0                                          NODE 1            â”‚ â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚
â”‚  â”‚  â”‚  CPU 0    CPU 1      â”‚                    â”‚  CPU 2    CPU 3      â”‚ â”‚ â”‚
â”‚  â”‚  â”‚   â–²         â–²        â”‚                    â”‚   â–²         â–²        â”‚ â”‚ â”‚
â”‚  â”‚  â”‚   â”‚         â”‚        â”‚    Interconnect    â”‚   â”‚         â”‚        â”‚ â”‚ â”‚
â”‚  â”‚  â”‚   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜        â”‚â—€â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â–¶â”‚   â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜        â”‚ â”‚ â”‚
â”‚  â”‚  â”‚        â”‚             â”‚      (QPI/UPI)     â”‚        â”‚             â”‚ â”‚ â”‚
â”‚  â”‚  â”‚        â–¼             â”‚                    â”‚        â–¼             â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚                    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚  Local RAM   â”‚    â”‚                    â”‚  â”‚  Local RAM   â”‚    â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚   (Fast)     â”‚    â”‚                    â”‚  â”‚   (Fast)     â”‚    â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â”‚   64 GB      â”‚    â”‚                    â”‚  â”‚   64 GB      â”‚    â”‚ â”‚ â”‚
â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚                    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚ â”‚ â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚
â”‚  â”‚                                                                       â”‚ â”‚
â”‚  â”‚  Access Latencies:                                                    â”‚ â”‚
â”‚  â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                                                    â”‚ â”‚
â”‚  â”‚  Local memory (same node):  ~80 ns                                   â”‚ â”‚
â”‚  â”‚  Remote memory (other node): ~150 ns                                 â”‚ â”‚
â”‚  â”‚                                                                       â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                                                             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### 8.2 NUMA-Aware Allocation

```rust
/// NUMA node identifier
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct NumaNode(pub u32);

/// NUMA-aware allocator
pub struct NumaAllocator {
    /// Per-node allocators
    nodes: Vec<NodeAllocator>,
    
    /// CPU to node mapping
    cpu_to_node: Vec<NumaNode>,
}

impl NumaAllocator {
    /// Allocate from the local node (preferred)
    pub fn allocate_local(&self) -> MemResult<Frame> {
        let cpu = current_cpu_id();
        let node = self.cpu_to_node[cpu];
        self.nodes[node.0 as usize].allocate()
    }
    
    /// Allocate from a specific node
    pub fn allocate_from_node(&self, node: NumaNode) -> MemResult<Frame> {
        self.nodes[node.0 as usize].allocate()
    }
    
    /// Allocate from any node (fallback)
    pub fn allocate_any(&self) -> MemResult<Frame> {
        // Try local first
        let cpu = current_cpu_id();
        let local_node = self.cpu_to_node[cpu];
        
        if let Ok(frame) = self.nodes[local_node.0 as usize].allocate() {
            return Ok(frame);
        }
        
        // Try other nodes
        for (i, node) in self.nodes.iter().enumerate() {
            if i != local_node.0 as usize {
                if let Ok(frame) = node.allocate() {
                    return Ok(frame);
                }
            }
        }
        
        Err(MemError::OutOfMemory)
    }
}
```

---

## 9. Memory Statistics

### 9.1 Statistics Structure

```rust
/// Memory statistics
#[derive(Debug, Clone)]
pub struct MemoryStats {
    /// Total physical memory (bytes)
    pub total_physical: u64,
    
    /// Free physical memory (bytes)
    pub free_physical: u64,
    
    /// Used physical memory (bytes)
    pub used_physical: u64,
    
    /// Total virtual memory mapped (bytes)
    pub total_virtual: u64,
    
    /// Used virtual memory (bytes)
    pub used_virtual: u64,
    
    /// Number of allocations
    pub allocations: u64,
    
    /// Number of deallocations
    pub deallocations: u64,
    
    /// Page faults
    pub page_faults: u64,
    
    /// TLB flushes
    pub tlb_flushes: u64,
}

impl MemoryStats {
    /// Get current memory statistics
    pub fn current() -> Self {
        let physical = PHYSICAL_ALLOCATOR.lock().stats();
        let virtual_mem = VIRTUAL_MEMORY.lock().stats();
        let heap = ALLOCATOR.stats();
        
        Self {
            total_physical: physical.total_bytes,
            free_physical: physical.free_bytes,
            used_physical: physical.used_bytes,
            total_virtual: virtual_mem.total_bytes,
            used_virtual: virtual_mem.used_bytes,
            allocations: heap.allocations,
            deallocations: heap.deallocations,
            page_faults: PAGE_FAULT_COUNT.load(Ordering::Relaxed),
            tlb_flushes: TLB_FLUSH_COUNT.load(Ordering::Relaxed),
        }
    }
    
    /// Print statistics to serial
    pub fn print(&self) {
        serial_println!("Memory Statistics:");
        serial_println!("  Physical Memory:");
        serial_println!("    Total:  {} MB", self.total_physical / 1024 / 1024);
        serial_println!("    Used:   {} MB", self.used_physical / 1024 / 1024);
        serial_println!("    Free:   {} MB", self.free_physical / 1024 / 1024);
        serial_println!("    Usage:  {}%", self.used_physical * 100 / self.total_physical);
        serial_println!("");
        serial_println!("  Virtual Memory:");
        serial_println!("    Mapped: {} MB", self.total_virtual / 1024 / 1024);
        serial_println!("    Used:   {} MB", self.used_virtual / 1024 / 1024);
        serial_println!("");
        serial_println!("  Allocations: {}", self.allocations);
        serial_println!("  Deallocations: {}", self.deallocations);
        serial_println!("  Page Faults: {}", self.page_faults);
    }
}
```

### 9.2 Memory Command

```rust
/// Shell command: mem
pub fn cmd_mem() {
    let stats = MemoryStats::current();
    
    serial_println!("");
    serial_println!("â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—");
    serial_println!("â•‘                    MEMORY STATISTICS                       â•‘");
    serial_println!("â• â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•£");
    serial_println!("â•‘                                                            â•‘");
    serial_println!("â•‘  Physical Memory:                                          â•‘");
    serial_println!("â•‘    Total:     {:>10} MB                                â•‘", 
        stats.total_physical / 1024 / 1024);
    serial_println!("â•‘    Used:      {:>10} MB                                â•‘", 
        stats.used_physical / 1024 / 1024);
    serial_println!("â•‘    Free:      {:>10} MB                                â•‘", 
        stats.free_physical / 1024 / 1024);
    serial_println!("â•‘                                                            â•‘");
    serial_println!("â•‘  Kernel Heap:                                              â•‘");
    serial_println!("â•‘    Allocations:   {:>8}                                 â•‘", 
        stats.allocations);
    serial_println!("â•‘    Deallocations: {:>8}                                 â•‘", 
        stats.deallocations);
    serial_println!("â•‘                                                            â•‘");
    serial_println!("â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•");
    serial_println!("");
}
```

---

## Summary

Helix's memory model provides:

1. **Physical Memory**: Frame-based allocation with bitmap/buddy allocators
2. **Virtual Memory**: 4-level page tables with full protection
3. **Kernel Heap**: Bump allocator for simplicity, upgradeable to slab
4. **Protection**: Ring 0/3 separation, NX bit, SMAP/SMEP support
5. **NUMA Awareness**: Node-local allocation for performance

For implementation details, see:
- [helix-memory/src/](../../subsystems/memory/src/)
- [helix-hal/src/mmu.rs](../../hal/src/mmu.rs)

---

<div align="center">

ğŸ§  *Memory management is the foundation of a stable operating system* ğŸ§ 

</div>
